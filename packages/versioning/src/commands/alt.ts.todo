import sha256 from "crypto-js/sha256";
import { enc } from "crypto-js";
import { Observable, of, throwError, forkJoin, combineLatest } from "rxjs";
import { Argv } from "yargs";
import { map, mergeMap, mergeAll, catchError } from "rxjs/operators";
import { seq, layer, proj, mapping } from "@abrovink/abmedium";
import defaultFileHandler from "../util/file-handler";
import { FileHandler } from "../util/types";
import {
  mainDir,
  objectsDir,
  timestampsLayer,
  counter,
  head,
  viewStack,
} from "../constants";

export const command = "alt [id]";

export const describe = "---";

export const builder = (yargs): Argv<{ id: string }> => {
  return yargs.positional("id", {
    describe: "the entity ID",
  });
};

// TODO move these
type LayerName = string;
type LayerWithSublayers = [LayerName, ViewStack];
type ViewStack = (LayerName | LayerWithSublayers)[];
type Layer = Object;

const any = (x: any): any => x;

export const layerStacking = (
  stack: ViewStack,
  path: string[] = [],
  stacking: string[][] = []
): string[][] => {
  for (const item of stack) {
    if (!item) continue;

    if (typeof item === "string") {
      stacking.push([...path, item]);
    } else {
      const [layerName, children] = item;
      stacking.push([...path, layerName]);
      layerStacking(children, [...path, layerName], stacking);
    }
  }
  return stacking;
};

export const layerByPath = (
  layer: Layer,
  path: string[]
): Layer | undefined => {
  let ret = layer;

  for (const handle of path) {
    ret = ret[handle];
    if (!ret) return undefined;
  }

  return ret;
};

const alt = ({
  fileHandler: { resolve, readFile, writeFile, glob } = defaultFileHandler,
  hasher = ({ fileName, data }) =>
    sha256(fileName + ":::" + data).toString(enc.Hex) +
    "." +
    fileName.split(".").slice(-1),
  now = () => new Date().toISOString(),
  archiveName,
  id,
}: {
  fileHandler?: FileHandler;
  hasher?: (options: { fileName: string; data: string }) => string;
  now?: () => string;
  archiveName: string;
  id: string;
}): Observable<void> => {
  const archivePath = resolve(archiveName);
  const mainDirPath = resolve(archivePath, mainDir);
  const objectsDirPath = resolve(mainDirPath, objectsDir);
  const idFileName = resolve(mainDirPath, id);

  return combineLatest(
    readFile(resolve(mainDirPath, viewStack), "utf8").pipe(
      map((data): ViewStack => JSON.parse(data))
    ),
    readFile(idFileName, "utf8").pipe(map((data) => JSON.parse(data))),
    glob(resolve(archiveName, id + ".*")).pipe(
      mergeAll(),
      mergeMap((fileName) =>
        forkJoin({ fileName: of(fileName), data: readFile(fileName, "utf8") })
      ),
      mergeMap(({ fileName, data }) => {
        const hashedName = hasher({ fileName, data });
        return forkJoin({
          hashedName: of(hashedName),
          _: writeFile(resolve(objectsDirPath, hashedName), data, "utf8"),
        });
      })
    )
  ).pipe(
    mergeMap(([stack, doc, { hashedName: altValue }]) => {
      const [altPath, ...rest] = layerStacking(stack).reverse();

      if (!altPath) {
        throw new Error("alt can not be used on the base layer");
      }

      const altLayer = layerByPath(doc, altPath);

      const projection = proj(doc, stack, [timestampsLayer]);

      let { [head]: h } = projection;

      let sourceValue;
      for (const sourcePath of [...rest, []]) {
        const sourceLayer = layerByPath(doc, sourcePath);

        if (!sourceLayer) continue;
        sourceValue = sourceLayer[h];
        if (sourceValue !== undefined) break;
      }

      let c = doc[counter];

      doc[counter] = c;

      return writeFile(idFileName, JSON.stringify(doc, null, 4), "utf8");
    }),
    catchError((err) => {
      console.error(err);
      return throwError(err);
    })
  );
};

export const handler = async ({ id }) =>
  new Promise((resolve) =>
    alt({ archiveName: process.cwd(), id }).subscribe(resolve)
  );

export default alt;
