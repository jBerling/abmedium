import { TestScheduler } from "rxjs/testing";
import { FileHandler } from "../util/types";
import { testFileHandler, TestFiles } from "../util/mocking/test-file-handler";
import alt, { layerStacking, layerByPath } from "./alt";
import { document, num, seq, nil, layer } from "@abrovink/abmedium";
import { mainDir, objectsDir, counter, viewStack, head } from "../constants";

const testScheduler = () =>
  new TestScheduler((actual, expected) => {
    expect(JSON.parse(JSON.stringify(actual))).toEqual(
      JSON.parse(JSON.stringify(expected))
    );
  });

const run = (fn) => () => testScheduler().run(fn);

const hasher = ({ fileName }: { fileName: string; data: string }): string =>
  `<${fileName.split(".")[0]}>.${fileName.split(".")[1]}`;

const now = () => "2020-07-20T18:36Z";

describe("abv alt", () => {
  let fileHandler: FileHandler;
  let archive: TestFiles;

  beforeEach(() => {
    archive = {
      [mainDir]: {
        [viewStack]: `["sub-layer", "alt-layer"]`,
        [objectsDir]: {},
        foo: JSON.stringify(
          document({
            [counter]: num(2),
            0: seq(nil, 1),
            1: "ver1.md",
            [head]: num(0),
          }),
          null,
          4
        ),
      },
      "foo.md": "# Foo\n",
    };
    fileHandler = testFileHandler(archive);
  });

  test(
    "adds alt version",
    run(({ expectObservable, flush }) => {
      expectObservable(
        alt({
          fileHandler,
          hasher,
          now,
          archiveName: "",
          id: "foo",
        })
      ).toBe("(a|)", { a: undefined });

      flush();

      expect(archive).toMatchSnapshot();
    })
  );
});

// TODO move
describe("layerStacking", () => {
  test("[]", () => expect(layerStacking([])).toEqual([]));
  test(`["a", "b", "c"]`, () => {
    expect(layerStacking(["a", "b", "c"])).toEqual([["a"], ["b"], ["c"]]);
  });
  test(`["a", ["b", ["b.1", "b.2"]], ["c", [["c.1", ["c.1.1", "c.1.2"]], "c.2"]]]`, () => {
    expect(
      layerStacking([
        "a",
        ["b", ["b.1", "b.2"]],
        ["c", [["c.1", ["c.1.1", "c.1.2"]], "c.2"]],
      ])
    ).toEqual([
      ["a"],
      ["b"],
      ["b", "b.1"],
      ["b", "b.2"],
      ["c"],
      ["c", "c.1"],
      ["c", "c.1", "c.1.1"],
      ["c", "c.1", "c.1.2"],
      ["c", "c.2"],
    ]);
  });
});

// TODO move
describe("layerByPath", () => {
  test("...", () => {
    expect(
      layerByPath(
        layer({
          a: layer({ b: layer({ c: layer({ name: "right" }) }) }),
          c: layer({ name: "wrong" }),
        }),
        ["a", "b", "c"]
      )
    ).toEqual(layer({ name: "right" }));
  });
});
